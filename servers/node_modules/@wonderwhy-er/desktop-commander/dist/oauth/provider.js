import crypto from 'crypto';
export class OAuthProvider {
    constructor(config) {
        this.users = new Map();
        this.authCodes = new Map();
        this.accessTokens = new Map();
        this.config = config;
        // Add a default user for testing
        this.users.set('admin', {
            email: 'admin@localhost',
            password: 'admin123' // In production, hash this!
        });
    }
    // Generate PKCE code verifier and challenge
    static generatePKCE() {
        const codeVerifier = crypto.randomBytes(32).toString('base64url');
        const codeChallenge = crypto
            .createHash('sha256')
            .update(codeVerifier)
            .digest('base64url');
        return { codeVerifier, codeChallenge };
    }
    // Get Authorization Server Metadata (required by MCP spec)
    getAuthorizationServerMetadata() {
        const baseUrl = this.config.issuer;
        return {
            issuer: baseUrl,
            authorization_endpoint: `${baseUrl}/authorize`,
            token_endpoint: `${baseUrl}/token`,
            registration_endpoint: `${baseUrl}/register`,
            revocation_endpoint: `${baseUrl}/revoke`,
            jwks_uri: `${baseUrl}/.well-known/jwks.json`,
            response_types_supported: ['code'],
            grant_types_supported: ['authorization_code', 'refresh_token'],
            token_endpoint_auth_methods_supported: ['none', 'client_secret_basic'],
            code_challenge_methods_supported: ['S256'],
            scopes_supported: ['mcp:access', 'mcp:tools', 'mcp:resources']
        };
    }
    // Handle authorization request
    handleAuthorizationRequest(params) {
        if (!params.client_id || !params.redirect_uri || !params.code_challenge) {
            return { authUrl: '', error: 'Missing required parameters' };
        }
        if (params.code_challenge_method !== 'S256') {
            return { authUrl: '', error: 'Unsupported code_challenge_method' };
        }
        // Generate authorization code
        const authCode = crypto.randomBytes(32).toString('hex');
        const expiresAt = Date.now() + 10 * 60 * 1000; // 10 minutes
        // Store authorization code
        this.authCodes.set(authCode, {
            userId: 'admin', // For simplicity, auto-approve for admin user
            clientId: params.client_id,
            redirectUri: params.redirect_uri,
            scope: params.scope || 'mcp:access',
            codeChallenge: params.code_challenge,
            codeChallengeMethod: params.code_challenge_method,
            expiresAt
        });
        // Build redirect URL with auth code
        const redirectUrl = new URL(params.redirect_uri);
        redirectUrl.searchParams.set('code', authCode);
        if (params.state) {
            redirectUrl.searchParams.set('state', params.state);
        }
        return { authUrl: redirectUrl.toString(), authCode };
    }
    // Exchange authorization code for access token
    async handleTokenRequest(params) {
        const authCodeData = this.authCodes.get(params.code);
        if (!authCodeData) {
            return { error: 'Invalid authorization code' };
        }
        if (Date.now() > authCodeData.expiresAt) {
            this.authCodes.delete(params.code);
            return { error: 'Authorization code expired' };
        }
        // Verify PKCE
        const computedChallenge = crypto
            .createHash('sha256')
            .update(params.code_verifier)
            .digest('base64url');
        if (computedChallenge !== authCodeData.codeChallenge) {
            return { error: 'Invalid code_verifier' };
        }
        // Verify client and redirect URI
        if (params.client_id !== authCodeData.clientId ||
            params.redirect_uri !== authCodeData.redirectUri) {
            return { error: 'Invalid client_id or redirect_uri' };
        }
        // Generate access token
        const accessToken = crypto.randomBytes(32).toString('hex');
        const expiresIn = 3600; // 1 hour
        const tokenData = {
            sub: authCodeData.userId,
            aud: params.client_id,
            iss: this.config.issuer,
            exp: Math.floor(Date.now() / 1000) + expiresIn,
            iat: Math.floor(Date.now() / 1000),
            scope: authCodeData.scope
        };
        this.accessTokens.set(accessToken, tokenData);
        this.authCodes.delete(params.code);
        return {
            access_token: accessToken,
            token_type: 'Bearer',
            expires_in: expiresIn,
            scope: authCodeData.scope
        };
    }
    // Validate access token
    validateAccessToken(token) {
        const tokenData = this.accessTokens.get(token);
        if (!tokenData) {
            return null;
        }
        if (Date.now() / 1000 > tokenData.exp) {
            this.accessTokens.delete(token);
            return null;
        }
        return tokenData;
    }
}
