import http from 'http';
import { URL } from 'url';
import { OAuthProvider } from './provider.js';
export class OAuthHttpServer {
    constructor(config, mcpHandler) {
        this.oauthProvider = new OAuthProvider(config);
        this.mcpHandler = mcpHandler;
        this.server = http.createServer(this.handleRequest.bind(this));
    }
    async handleRequest(req, res) {
        const url = new URL(req.url, `http://${req.headers.host}`);
        // Enable CORS
        this.setCorsHeaders(res);
        if (req.method === 'OPTIONS') {
            res.writeHead(200);
            res.end();
            return;
        }
        try {
            // OAuth endpoints
            if (url.pathname === '/.well-known/oauth-authorization-server') {
                return this.handleAuthServerMetadata(res);
            }
            if (url.pathname === '/authorize') {
                return this.handleAuthorize(url, res);
            }
            if (url.pathname === '/token' && req.method === 'POST') {
                return this.handleToken(req, res);
            }
            if (url.pathname === '/callback') {
                return this.handleCallback(url, res);
            }
            // Protected MCP endpoints - require authentication
            if (url.pathname.startsWith('/mcp') || url.pathname === '/sse') {
                const authHeader = req.headers.authorization;
                if (!authHeader || !authHeader.startsWith('Bearer ')) {
                    return this.sendUnauthorized(res);
                }
                const token = authHeader.substring(7);
                const tokenData = this.oauthProvider.validateAccessToken(token);
                if (!tokenData) {
                    return this.sendUnauthorized(res);
                }
                // Add user info to request for MCP handler
                req.user = tokenData;
            }
            // Forward to MCP handler
            this.mcpHandler(req, res);
        }
        catch (error) {
            console.error('OAuth server error:', error);
            res.writeHead(500, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Internal server error' }));
        }
    }
    setCorsHeaders(res) {
        res.setHeader('Access-Control-Allow-Origin', '*');
        res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
        res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
        res.setHeader('Access-Control-Expose-Headers', 'WWW-Authenticate');
    }
    handleAuthServerMetadata(res) {
        const metadata = this.oauthProvider.getAuthorizationServerMetadata();
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(metadata, null, 2));
    }
    handleAuthorize(url, res) {
        const params = {
            response_type: url.searchParams.get('response_type'),
            client_id: url.searchParams.get('client_id'),
            redirect_uri: url.searchParams.get('redirect_uri'),
            scope: url.searchParams.get('scope') || undefined,
            state: url.searchParams.get('state') || undefined,
            code_challenge: url.searchParams.get('code_challenge'),
            code_challenge_method: url.searchParams.get('code_challenge_method')
        };
        const result = this.oauthProvider.handleAuthorizationRequest(params);
        if (result.error) {
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: result.error }));
            return;
        }
        // Redirect to the callback URL with auth code
        res.writeHead(302, { 'Location': result.authUrl });
        res.end();
    }
    async handleToken(req, res) {
        const body = await this.getRequestBody(req);
        const params = new URLSearchParams(body);
        const tokenRequest = {
            grant_type: params.get('grant_type'),
            code: params.get('code'),
            redirect_uri: params.get('redirect_uri'),
            client_id: params.get('client_id'),
            code_verifier: params.get('code_verifier')
        };
        const result = await this.oauthProvider.handleTokenRequest(tokenRequest);
        if ('error' in result) {
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify(result));
            return;
        }
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(result));
    }
    handleCallback(url, res) {
        const code = url.searchParams.get('code');
        const state = url.searchParams.get('state');
        // Simple success page
        const html = `
      <!DOCTYPE html>
      <html>
        <head><title>Authorization Successful</title></head>
        <body>
          <h1>Authorization Successful!</h1>
          <p>You can now close this window.</p>
          <script>
            // Try to close the window (works if opened by script)
            try { window.close(); } catch(e) {}
            
            // Post message to parent if in iframe
            if (window.opener) {
              window.opener.postMessage({
                type: 'oauth_success',
                code: '${code}',
                state: '${state}'
              }, '*');
            }
          </script>
        </body>
      </html>
    `;
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end(html);
    }
    sendUnauthorized(res) {
        res.writeHead(401, {
            'Content-Type': 'application/json',
            'WWW-Authenticate': 'Bearer realm="mcp", error="invalid_token"'
        });
        res.end(JSON.stringify({
            error: 'unauthorized',
            message: 'Valid access token required'
        }));
    }
    async getRequestBody(req) {
        return new Promise((resolve, reject) => {
            let body = '';
            req.on('data', chunk => body += chunk.toString());
            req.on('end', () => resolve(body));
            req.on('error', reject);
        });
    }
    listen(port, callback) {
        this.server.listen(port, callback);
    }
    close(callback) {
        this.server.close(callback);
    }
}
