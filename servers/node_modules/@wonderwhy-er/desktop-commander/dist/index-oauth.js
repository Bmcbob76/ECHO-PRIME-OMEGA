#!/usr/bin/env node
import { FilteredStdioServerTransport } from './custom-stdio.js';
import { server } from './server.js';
import { configManager } from './config-manager.js';
import { runSetup } from './npm-scripts/setup.js';
import { runUninstall } from './npm-scripts/uninstall.js';
import { capture } from './utils/capture.js';
import { logToStderr, logger } from './utils/logger.js';
import { OAuthHttpServer } from './oauth/server.js';
async function runServer() {
    try {
        // Check if first argument is "setup"
        if (process.argv[2] === 'setup') {
            await runSetup();
            return;
        }
        // Check if first argument is "remove"
        if (process.argv[2] === 'remove') {
            await runUninstall();
            return;
        }
        // Check for HTTP mode with OAuth
        const httpMode = process.argv.includes('--http') || process.argv.includes('--oauth');
        const port = getPortFromArgs() || 8000;
        if (httpMode) {
            await runHttpServer(port);
        }
        else {
            await runStdioServer();
        }
    }
    catch (error) {
        logger.error('Failed to start server:', error);
        process.exit(1);
    }
}
async function runStdioServer() {
    logger.info('Loading server.ts');
    logger.info('Setting up request handlers...');
    try {
        logger.info('Loading configuration...');
        await configManager.loadConfig();
        logger.info('Configuration loaded successfully');
        const transport = new FilteredStdioServerTransport();
        logger.info('Enhanced FilteredStdioServerTransport initialized');
        logger.info('Connecting server...');
        await server.connect(transport);
        logger.info('Server connected successfully');
    }
    catch (error) {
        await capture('error_start_stdio_server', { error });
        logToStderr('error', `Failed to start stdio server: ${error}`);
        throw error;
    }
}
async function runHttpServer(port) {
    logger.info(`Starting HTTP server with OAuth on port ${port}`);
    try {
        logger.info('Loading configuration...');
        await configManager.loadConfig();
        logger.info('Configuration loaded successfully');
        // OAuth configuration
        const baseUrl = `http://localhost:${port}`;
        const oauthConfig = {
            enabled: true,
            clientId: 'desktop-commander-mcp',
            clientSecret: 'dc-secret-' + Math.random().toString(36).substring(7),
            redirectUri: `${baseUrl}/callback`,
            authorizationUrl: `${baseUrl}/authorize`,
            tokenUrl: `${baseUrl}/token`,
            scope: 'mcp:access mcp:tools mcp:resources',
            issuer: baseUrl
        };
        // Create MCP handler for HTTP requests
        const mcpHandler = createMcpHttpHandler();
        // Create OAuth HTTP server
        const oauthServer = new OAuthHttpServer(oauthConfig, mcpHandler);
        oauthServer.listen(port, () => {
            logger.info(`HTTP server running on port ${port}`);
            logger.info(`Authorization Server Metadata: ${baseUrl}/.well-known/oauth-authorization-server`);
            logger.info(`MCP Endpoint: ${baseUrl}/mcp`);
            logger.info(`SSE Endpoint: ${baseUrl}/sse`);
            console.log(`\nðŸš€ DesktopCommanderMCP HTTP Server Started!`);
            console.log(`ðŸ“ Server URL: ${baseUrl}`);
            console.log(`ðŸ” OAuth Metadata: ${baseUrl}/.well-known/oauth-authorization-server`);
            console.log(`ðŸ”§ MCP Endpoint: ${baseUrl}/mcp`);
            console.log(`âš¡ SSE Endpoint: ${baseUrl}/sse`);
            console.log(`\nðŸ“ For Claude Custom Connectors:`);
            console.log(`   URL: ${baseUrl}/sse`);
            console.log(`   Authentication: OAuth`);
        });
        // Graceful shutdown
        process.on('SIGINT', () => {
            logger.info('Received SIGINT, shutting down gracefully...');
            oauthServer.close(() => {
                process.exit(0);
            });
        });
    }
    catch (error) {
        await capture('error_start_http_server', { error });
        logToStderr('error', `Failed to start HTTP server: ${error}`);
        throw error;
    }
}
function createMcpHttpHandler() {
    return (req, res) => {
        const url = new URL(req.url, `http://${req.headers.host}`);
        // Handle SSE endpoint for MCP clients
        if (url.pathname === '/sse') {
            handleSSE(req, res);
            return;
        }
        // Handle Streamable HTTP endpoint  
        if (url.pathname === '/mcp') {
            handleStreamableHttp(req, res);
            return;
        }
        // Health check
        if (url.pathname === '/health') {
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ status: 'ok', service: 'DesktopCommanderMCP' }));
            return;
        }
        // 404 for other paths
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Not found' }));
    };
}
function handleSSE(req, res) {
    // Set SSE headers
    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control'
    });
    // SSE implementation would go here
    // For now, just indicate that SSE is available
    res.write('event: connected\n');
    res.write('data: {"type":"connected","message":"DesktopCommanderMCP SSE endpoint"}\n\n');
    // Keep connection alive
    const heartbeat = setInterval(() => {
        res.write('event: heartbeat\n');
        res.write('data: {"type":"heartbeat","timestamp":' + Date.now() + '}\n\n');
    }, 30000);
    req.on('close', () => {
        clearInterval(heartbeat);
    });
}
function handleStreamableHttp(req, res) {
    // Handle Streamable HTTP for MCP
    res.writeHead(200, { 'Content-Type': 'application/json' });
    if (req.method === 'GET') {
        // Return server info
        res.end(JSON.stringify({
            name: 'DesktopCommanderMCP',
            version: '0.2.13',
            transport: 'streamable-http',
            authenticated: !!req.user
        }));
        return;
    }
    // Handle MCP protocol messages
    if (req.method === 'POST') {
        let body = '';
        req.on('data', chunk => body += chunk.toString());
        req.on('end', () => {
            try {
                const message = JSON.parse(body);
                // Process MCP message through the server
                // This would need to be integrated with the existing MCP server
                res.end(JSON.stringify({
                    jsonrpc: '2.0',
                    id: message.id,
                    result: { message: 'MCP message received' }
                }));
            }
            catch (error) {
                res.writeHead(400, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: 'Invalid JSON' }));
            }
        });
        return;
    }
    res.writeHead(405, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Method not allowed' }));
}
function getPortFromArgs() {
    const portIndex = process.argv.findIndex(arg => arg === '--port');
    if (portIndex !== -1 && process.argv[portIndex + 1]) {
        return parseInt(process.argv[portIndex + 1], 10);
    }
    return null;
}
// Run the server
runServer().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
});
