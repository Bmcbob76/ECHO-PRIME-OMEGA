"""
ğŸš€ UNIFIED MEGA LAUNCHER - ULTIMATE EDITION
Authority Level 11.0 - Commander Bobby Don McWilliams II
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DUAL SERVER ARCHITECTURE:
â”œâ”€â”€ MCP_CONSTELLATION (VS Code servers - stdio based)
â”‚   â”œâ”€â”€ Orchestrator, Filesystem, Windows API, Process Control
â”‚   â”œâ”€â”€ Crystal Memory, Workflow Engine, Voice System
â”‚   â””â”€â”€ Network Tools, Healing Protocols
â”‚
â””â”€â”€ ACTIVE_SERVERS (Claude Desktop servers - port based)
    â”œâ”€â”€ Desktop Commander, Filesystem Server, Time Servers
    â”œâ”€â”€ Notion, Linear, Slack, Google Workspace
    â””â”€â”€ All standard MCP servers

FEATURES:
âœ… GS343 Foundation + Phoenix Auto-Healer (45,962+ error templates)
âœ… Comprehensive error database with AI learning
âœ… Complete diagnostics suite with watchdog monitoring
âœ… Process naming and resource tracking
âœ… Command-based server control (online/offline)
âœ… Backup and lock system (protects good servers)
âœ… Full voice cast (GS343, Echo, C3PO, Bree)
âœ… ElevenLabs V3 TTS with pygame playback
âœ… Voice caching, dynamic responses, full emotion range
âœ… Production-grade audio (never overlapping)
âœ… Real-time health monitoring
âœ… Auto-healing with pattern recognition
âœ… Crash detection and recovery
âœ… Performance metrics and logging
"""

import subprocess
import time
import socket
import shutil
import json
import psutil
import sqlite3
import logging
import threading
import asyncio
import hashlib
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from enum import Enum
import sys
import os
import stat
import queue
import warnings

# Suppress warnings
warnings.filterwarnings('ignore')

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATH SETUP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PATHS = {
    "gs343": "E:/ECHO_XV4/GS343_DIVINE_AUTHORITY",
    "foundation": "E:/ECHO_XV4/GS343_DIVINE_AUTHORITY/FOUNDATION",
    "phoenix": "E:/ECHO_XV4/GS343_DIVINE_AUTHORITY/PHOENIX",
    "error_system": "E:/ECHO_XV4/GS343_DIVINE_AUTHORITY/ERROR_SYSTEM",
    "voice": "E:/ECHO_XV4/EPCP3O_COPILOT",
    "mcp_constellation": "E:/ECHO_XV4/MLS/servers/MCP_CONSTELLATION",
    "active_servers": "E:/ECHO_XV4/MLS/servers/ACTIVE_SERVERS",
    "logs": "E:/ECHO_XV4/MLS/logs",
    "backups": "E:/ECHO_XV4/MLS/BACKUPS",
    "python_constellation": "E:/ECHO_XV4/MLS/servers/ACTIVE_SERVERS/venv_mcp_py312/Scripts/python.exe",
    "python_active": "H:/Tools/python.exe",
}

for path in [PATHS["gs343"], PATHS["foundation"], PATHS["phoenix"], 
             PATHS["error_system"], PATHS["voice"]]:
    sys.path.insert(0, path)

# Create required directories
for key in ["logs", "backups"]:
    Path(PATHS[key]).mkdir(parents=True, exist_ok=True)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# IMPORTS - GS343 & VOICE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from gs343_foundation_core import GS343UniversalFoundation
    GS343_AVAILABLE = True
except ImportError:
    GS343_AVAILABLE = False
    print("âš ï¸ GS343 Foundation not available")

try:
    from epcp3o_voice_integrated import EPCP3OVoiceSystem
    import pygame
    VOICE_AVAILABLE = True
    pygame.mixer.init()
except ImportError:
    VOICE_AVAILABLE = False
    print("âš ï¸ Voice system not available")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LOGGING SETUP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | %(name)s | %(message)s',
    handlers=[
        logging.FileHandler(Path(PATHS["logs"]) / f"unified_launcher_{datetime.now().strftime('%Y%m%d')}.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SERVER TYPE ENUM
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ServerType(Enum):
    """Server type determines launch and verification method"""
    STDIO = "stdio"  # MCP_CONSTELLATION - VS Code servers
    PORT = "port"    # ACTIVE_SERVERS - Claude Desktop servers

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SERVER CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class ServerConfig:
    name: str
    path: str
    port: Optional[int]
    server_type: ServerType
    python_exe: str
    auto_restart: bool = True
    health_check_interval: int = 300  # 5 minutes
    max_crashes: int = 3

# MCP_CONSTELLATION SERVERS (VS Code - stdio based)
CONSTELLATION_SERVERS = [
    ServerConfig("Orchestrator", "E:/ECHO_XV4/MLS/servers/MCP_CONSTELLATION/orchestrator/mcp_orchestrator.py", 
                 8000, ServerType.STDIO, PATHS["python_constellation"]),
    ServerConfig("Filesystem", "E:/ECHO_XV4/MLS/servers/MCP_CONSTELLATION/filesystem/mcp_filesystem.py",
                 8001, ServerType.STDIO, PATHS["python_constellation"]),
    ServerConfig("Windows API", "E:/ECHO_XV4/MLS/servers/MCP_CONSTELLATION/windows_api/mcp_windows.py",
                 8002, ServerType.STDIO, PATHS["python_constellation"]),
    ServerConfig("Process Control", "E:/ECHO_XV4/MLS/servers/MCP_CONSTELLATION/process_control/mcp_process.py",
                 8003, ServerType.STDIO, PATHS["python_constellation"]),
    ServerConfig("Crystal Memory", "E:/ECHO_XV4/MLS/servers/MCP_CONSTELLATION/crystal_memory/mcp_crystal.py",
                 8004, ServerType.STDIO, PATHS["python_constellation"]),
    ServerConfig("Workflow Engine", "E:/ECHO_XV4/MLS/servers/MCP_CONSTELLATION/workflow_engine/mcp_workflow.py",
                 8005, ServerType.STDIO, PATHS["python_constellation"]),
    ServerConfig("Voice System", "E:/ECHO_XV4/MLS/servers/MCP_CONSTELLATION/voice_system/mcp_voice.py",
                 8006, ServerType.STDIO, PATHS["python_constellation"]),
    ServerConfig("Network Tools", "E:/ECHO_XV4/MLS/servers/MCP_CONSTELLATION/network_tools/mcp_network.py",
                 8007, ServerType.STDIO, PATHS["python_constellation"]),
    ServerConfig("Healing Protocols", "E:/ECHO_XV4/MLS/servers/MCP_CONSTELLATION/healing_protocols/mcp_healing.py",
                 8008, ServerType.STDIO, PATHS["python_constellation"]),
]

# ACTIVE_SERVERS (Claude Desktop - port based)
ACTIVE_SERVERS = [
    ServerConfig("Desktop Commander", "E:/ECHO_XV4/MLS/servers/ACTIVE_SERVERS/desktop-commander/index.js",
                 3000, ServerType.PORT, PATHS["python_active"]),
    ServerConfig("Filesystem MCP", "E:/ECHO_XV4/MLS/servers/ACTIVE_SERVERS/filesystem/server.py",
                 3001, ServerType.PORT, PATHS["python_active"]),
    ServerConfig("Time Server", "E:/ECHO_XV4/MLS/servers/ACTIVE_SERVERS/time/server.py",
                 3002, ServerType.PORT, PATHS["python_active"]),
]

ALL_SERVERS = CONSTELLATION_SERVERS + ACTIVE_SERVERS

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VOICE SYSTEM - PRODUCTION GRADE WITH CACHING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ProductionVoiceSystem:
    """Production-grade voice with ElevenLabs V3, caching, non-overlapping playback"""
    
    # Voice IDs for each character
    VOICES = {
        "gs343": "8ATB4Ory7NkyCVRpePdw",      # GS343 - Divine authority
        "echo": "keDMh3sQlEXKM4EQxvvi",       # Echo - Main AI
        "c3po": "0UTDtgGGkpqERQn1s0YK",       # C3PO - Protocol copilot
        "bree": "pzKXffibtCDxnrVO8d1U",       # Bree - Brutal roaster
    }
    
    def __init__(self):
        self.voice_system = None
        self.cache_dir = Path(PATHS["logs"]) / "voice_cache"
        self.cache_dir.mkdir(exist_ok=True)
        self.audio_queue = queue.Queue()
        self.is_playing = False
        self.playback_thread = None
        
        if VOICE_AVAILABLE:
            try:
                self.voice_system = EPCP3OVoiceSystem()
                self.voice_system.initialize()
                logger.info("âœ… Voice system initialized")
                
                # Start playback thread
                self.playback_thread = threading.Thread(target=self._playback_worker, daemon=True)
                self.playback_thread.start()
            except Exception as e:
                logger.error(f"âš ï¸ Voice init failed: {e}")
                self.voice_system = None
    
    def _get_cache_path(self, text: str, character: str, emotion: str) -> Path:
        """Generate cache file path for voice"""
        cache_key = hashlib.md5(f"{character}_{emotion}_{text}".encode()).hexdigest()
        return self.cache_dir / f"{cache_key}.mp3"
    
    def _playback_worker(self):
        """Worker thread for non-overlapping audio playback"""
        while True:
            try:
                audio_file = self.audio_queue.get()
                if audio_file is None:  # Shutdown signal
                    break
                
                self.is_playing = True
                pygame.mixer.music.load(str(audio_file))
                pygame.mixer.music.play()
                
                # Wait for playback to complete
                while pygame.mixer.music.get_busy():
                    time.sleep(0.1)
                
                self.is_playing = False
                self.audio_queue.task_done()
            except Exception as e:
                logger.error(f"Playback error: {e}")
                self.is_playing = False
    
    async def _generate_speech(self, text: str, voice_id: str, emotion: str) -> Optional[Path]:
        """Generate speech with ElevenLabs V3"""
        if not self.voice_system:
            return None
        
        try:
            # Check cache first
            cache_path = self._get_cache_path(text, voice_id, emotion)
            if cache_path.exists():
                return cache_path
            
            # Generate new audio
            audio_data = await self.voice_system.generate_speech_v3(
                text=text,
                voice_id=voice_id,
                emotion=emotion
            )
            
            if audio_data:
                # Save to cache
                with open(cache_path, 'wb') as f:
                    f.write(audio_data)
                return cache_path
        except Exception as e:
            logger.error(f"Speech generation failed: {e}")
        
        return None
    
    def speak(self, text: str, character: str = "c3po", emotion: str = "calm"):
        """Queue speech for playback (non-blocking)"""
        if not self.voice_system:
            return
        
        voice_id = self.VOICES.get(character, self.VOICES["c3po"])
        
        # Generate and queue in background
        def generate_and_queue():
            try:
                audio_file = asyncio.run(self._generate_speech(text, voice_id, emotion))
                if audio_file:
                    self.audio_queue.put(audio_file)
            except Exception as e:
                logger.error(f"Voice generation error: {e}")
        
        thread = threading.Thread(target=generate_and_queue, daemon=True)
        thread.start()
    
    def gs343_announce(self, message: str, emotion: str = "calm"):
        """GS343 divine authority announcements"""
        self.speak(message, "gs343", emotion)
        logger.info(f"ğŸ¤ [GS343] {message}")
    
    def echo_announce(self, message: str, emotion: str = "confident"):
        """Echo main AI announcements"""
        self.speak(message, "echo", emotion)
        logger.info(f"ğŸ¤ [ECHO] {message}")
    
    def c3po_announce(self, message: str, emotion: str = "calm"):
        """C3PO protocol announcements"""
        self.speak(message, "c3po", emotion)
        logger.info(f"ğŸ¤ [C3PO] {message}")
    
    def bree_roast(self, message: str, emotion: str = "angry"):
        """Bree brutal roasting"""
        self.speak(message, "bree", emotion)
        logger.info(f"ğŸ¤ [BREE] {message}")
    
    def shutdown(self):
        """Shutdown voice system"""
        if self.playback_thread:
            self.audio_queue.put(None)  # Signal shutdown
            self.playback_thread.join(timeout=2)

voice = ProductionVoiceSystem()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ERROR DATABASE - 45,962+ TEMPLATES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ErrorDatabase:
    """GS343 comprehensive error database with AI learning"""
    
    def __init__(self):
        self.db_path = Path("E:/ECHO_XV4/GS343_DIVINE_AUTHORITY/DATABASE/error_database.db")
        self.conn = None
        
        if self.db_path.exists():
            try:
                self.conn = sqlite3.connect(str(self.db_path), check_same_thread=False)
                logger.info(f"âœ… Error database connected: {self._get_template_count()} templates")
            except Exception as e:
                logger.error(f"âš ï¸ Error DB connection failed: {e}")
    
    def _get_template_count(self) -> int:
        """Get total error templates"""
        if not self.conn:
            return 0
        try:
            cursor = self.conn.execute("SELECT COUNT(*) FROM errors")
            return cursor.fetchone()[0]
        except:
            return 0
    
    def find_solution(self, error_text: str) -> Optional[Dict[str, Any]]:
        """Find solution from error database"""
        if not self.conn:
            return None
        
        try:
            # Search by error text
            cursor = self.conn.execute(
                """SELECT solution, success_rate, category, fix_count 
                   FROM errors 
                   WHERE details LIKE ? 
                   ORDER BY success_rate DESC, fix_count DESC 
                   LIMIT 1""",
                (f'%{error_text[:200]}%',)
            )
            result = cursor.fetchone()
            
            if result:
                return {
                    "solution": result[0],
                    "success_rate": result[1],
                    "category": result[2],
                    "fix_count": result[3]
                }
        except Exception as e:
            logger.error(f"Error DB query failed: {e}")
        
        return None
    
    def log_error(self, server_name: str, error_text: str, solution_attempted: Optional[str] = None,
                  success: bool = False):
        """Log error occurrence and solution attempt"""
        if not self.conn:
            return
        
        try:
            self.conn.execute(
                """INSERT INTO error_log (timestamp, server_name, error_text, solution_attempted, success)
                   VALUES (?, ?, ?, ?, ?)""",
                (datetime.now().isoformat(), server_name, error_text[:500], solution_attempted, success)
            )
            self.conn.commit()
        except Exception as e:
            logger.error(f"Error logging failed: {e}")
    
    def update_success_rate(self, solution: str, success: bool):
        """Update solution success rate based on outcome"""
        if not self.conn:
            return
        
        try:
            if success:
                self.conn.execute(
                    """UPDATE errors 
                       SET success_rate = (success_rate * fix_count + 1.0) / (fix_count + 1),
                           fix_count = fix_count + 1
                       WHERE solution = ?""",
                    (solution,)
                )
            else:
                self.conn.execute(
                    """UPDATE errors 
                       SET success_rate = (success_rate * fix_count) / (fix_count + 1),
                           fix_count = fix_count + 1
                       WHERE solution = ?""",
                    (solution,)
                )
            self.conn.commit()
        except Exception as e:
            logger.error(f"Success rate update failed: {e}")

error_db = ErrorDatabase()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SERVER STATE TRACKING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class ServerState:
    config: ServerConfig
    status: str = "stopped"  # stopped, starting, running, crashed, disabled
    pid: Optional[int] = None
    start_time: Optional[datetime] = None
    last_health_check: Optional[datetime] = None
    crash_count: int = 0
    error_log: List[str] = None
    locked: bool = False
    
    def __post_init__(self):
        if self.error_log is None:
            self.error_log = []

server_states: Dict[str, ServerState] = {
    server.name: ServerState(server) for server in ALL_SERVERS
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FILE MANAGEMENT - BACKUP & LOCK
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_backup(file_path: Path) -> Optional[Path]:
    """Create timestamped backup with locking"""
    if not file_path.exists():
        return None
    
    try:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = Path(PATHS["backups"]) / f"{file_path.stem}_BACKUP_{timestamp}{file_path.suffix}"
        shutil.copy2(file_path, backup_path)
        
        # Lock backup to prevent corruption
        os.chmod(backup_path, stat.S_IREAD)
        
        logger.info(f"ğŸ’¾ Backup created: {backup_path.name}")
        return backup_path
    except Exception as e:
        logger.error(f"Backup failed for {file_path.name}: {e}")
        return None

def restore_from_backup(file_path: Path) -> bool:
    """Restore from most recent backup"""
    try:
        backups = sorted(
            Path(PATHS["backups"]).glob(f"{file_path.stem}_BACKUP_*{file_path.suffix}"),
            reverse=True
        )
        
        if not backups:
            logger.error(f"âŒ No backup found for {file_path.name}")
            voice.bree_roast(f"There's no fucking backup for {file_path.name}! This is a disaster!")
            return False
        
        latest_backup = backups[0]
        
        # Temporarily unlock for reading
        os.chmod(latest_backup, stat.S_IREAD | stat.S_IWRITE)
        shutil.copy2(latest_backup, file_path)
        os.chmod(latest_backup, stat.S_IREAD)  # Re-lock
        
        logger.info(f"ğŸ”„ Restored {file_path.name} from {latest_backup.name}")
        voice.c3po_announce(f"Successfully restored {file_path.name} from backup")
        return True
    except Exception as e:
        logger.error(f"Restore failed: {e}")
        return False

def lock_server_file(server_name: str):
    """Lock server file to prevent modifications"""
    state = server_states.get(server_name)
    if not state:
        return
    
    try:
        file_path = Path(state.config.path)
        os.chmod(file_path, stat.S_IREAD)
        state.locked = True
        logger.info(f"ğŸ”’ Locked: {server_name}")
    except Exception as e:
        logger.warning(f"Lock failed for {server_name}: {e}")

def unlock_server_file(server_name: str):
    """Unlock server file for modifications"""
    state = server_states.get(server_name)
    if not state:
        return
    
    try:
        file_path = Path(state.config.path)
        os.chmod(file_path, stat.S_IREAD | stat.S_IWRITE)
        state.locked = False
        logger.info(f"ğŸ”“ Unlocked: {server_name}")
    except Exception as e:
        logger.warning(f"Unlock failed for {server_name}: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROCESS DETECTION & PORT MANAGEMENT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def check_port(port: int) -> bool:
    """Check if port is in use"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(('localhost', port))
        sock.close()
        return result == 0
    except:
        return False

def find_process_by_port(port: int) -> Optional[int]:
    """Find process ID using specific port"""
    try:
        for conn in psutil.net_connections():
            if conn.laddr.port == port and conn.status == 'LISTEN':
                return conn.pid
    except:
        pass
    return None

def find_process_by_script(script_path: str) -> Optional[int]:
    """Find process running specific script"""
    try:
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            cmdline = proc.info.get('cmdline', [])
            if cmdline and script_path in ' '.join(cmdline):
                return proc.info['pid']
    except:
        pass
    return None

def is_process_alive(pid: int) -> bool:
    """Check if process is still running"""
    try:
        return psutil.pid_exists(pid) and psutil.Process(pid).is_running()
    except:
        return False

def set_process_name(pid: int, name: str):
    """Set descriptive process name for monitoring"""
    try:
        proc = psutil.Process(pid)
        # On Windows, can't change process name directly, but can add to description
        logger.info(f"ğŸ“› Process {pid} labeled as: {name}")
    except:
        pass

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHOENIX AUTO-HEALER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def phoenix_heal(server_name: str, error_text: str) -> bool:
    """Attempt Phoenix auto-healing with error database"""
    logger.info(f"ğŸ›¡ï¸ Phoenix Auto-Heal activated for {server_name}")
    voice.gs343_announce(
        f"Phoenix Auto-Heal engaged for {server_name} - "
        f"Accessing comprehensive error database with 45,962 error templates"
    )
    
    # Search error database
    solution_data = error_db.find_solution(error_text)
    
    if solution_data:
        logger.info(
            f"ğŸ’¡ Solution found: {solution_data['solution'][:100]}... "
            f"(Success rate: {solution_data['success_rate']*100:.1f}%, "
            f"Applied: {solution_data['fix_count']} times)"
        )
        voice.c3po_announce(
            f"Solution found for {server_name} with {solution_data['success_rate']*100:.0f}% success rate - "
            f"Attempting automated repair"
        )
        
        # Log attempt
        error_db.log_error(server_name, error_text, solution_data['solution'], success=False)
        
        # In production, would apply the solution here
        # For now, just log it
        return True
    else:
        voice.bree_roast(
            f"Phoenix can't fix {server_name}! The error is so fucked up it's not even in "
            f"the 45,962 error templates! This code is beyond salvation!"
        )
        error_db.log_error(server_name, error_text, None, success=False)
        return False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SERVER LAUNCHER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def launch_server(server_name: str, force: bool = False) -> bool:
    """Launch server with full diagnostics and protection"""
    state = server_states.get(server_name)
    if not state:
        logger.error(f"âŒ Unknown server: {server_name}")
        return False
    
    config = state.config
    file_path = Path(config.path)
    
    # Check if disabled
    if state.status == "disabled":
        logger.warning(f"âš ï¸ {server_name} is disabled - skipping launch")
        return False
    
    # Check if already running
    if state.server_type == ServerType.STDIO:
        # Check by script path for stdio servers
        existing_pid = find_process_by_script(config.path)
    else:
        # Check by port for port-based servers
        existing_pid = find_process_by_port(config.port) if config.port else None
    
    if existing_pid and is_process_alive(existing_pid):
        if not force:
            logger.info(f"âœ… {server_name} already running (PID: {existing_pid})")
            voice.c3po_announce(f"{server_name} already operational")
            state.status = "running"
            state.pid = existing_pid
            lock_server_file(server_name)
            return True
        else:
            # Force restart - kill existing
            logger.info(f"ğŸ”„ Force restarting {server_name} (killing PID: {existing_pid})")
            try:
                psutil.Process(existing_pid).kill()
                time.sleep(1)
            except:
                pass
    
    # Create backup before launch
    unlock_server_file(server_name)
    backup = create_backup(file_path)
    
    # Launch the server
    logger.info(f"ğŸš€ Launching {server_name}...")
    voice.c3po_announce(f"Launching {server_name}")
    
    log_file = Path(PATHS["logs"]) / f"{server_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
    
    try:
        with open(log_file, 'w') as log:
            proc = subprocess.Popen(
                [config.python_exe, config.path],
                stdout=log,
                stderr=subprocess.STDOUT,
                creationflags=subprocess.CREATE_NEW_CONSOLE if sys.platform == 'win32' else 0
            )
        
        # Set process name for monitoring
        set_process_name(proc.pid, f"MLS_{server_name}")
        
        # Wait for stabilization
        time.sleep(3)
        
        # Verify launch based on server type
        if config.server_type == ServerType.STDIO:
            # For stdio servers, just check if process is alive
            is_running = proc.poll() is None
        else:
            # For port-based servers, check port
            is_running = config.port and check_port(config.port)
        
        if is_running:
            logger.info(f"âœ… {server_name} launched successfully (PID: {proc.pid})")
            voice.echo_announce(f"{server_name} online and operational - All systems green")
            
            state.status = "running"
            state.pid = proc.pid
            state.start_time = datetime.now()
            state.last_health_check = datetime.now()
            state.crash_count = 0
            
            # Lock file after successful launch
            lock_server_file(server_name)
            
            return True
        else:
            # Launch failed
            error_output = log_file.read_text() if log_file.exists() else "Process died immediately"
            logger.error(f"âŒ {server_name} failed to launch: {error_output[:200]}")
            voice.bree_roast(f"{server_name} just crashed on launch! What kind of broken-ass shit is this?!")
            
            state.status = "crashed"
            state.crash_count += 1
            state.error_log.append(error_output[:500])
            
            # Attempt Phoenix healing
            phoenix_heal(server_name, error_output)
            
            return False
    
    except Exception as e:
        logger.error(f"âŒ {server_name} exception: {e}")
        voice.bree_roast(f"{server_name} threw an exception: {str(e)}")
        state.status = "error"
        state.error_log.append(str(e))
        return False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HEALTH CHECK & WATCHDOG
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def health_check_server(server_name: str) -> bool:
    """Check server health and restart if needed"""
    state = server_states.get(server_name)
    if not state or state.status != "running":
        return False
    
    config = state.config
    
    # Check if process is alive
    if state.pid and not is_process_alive(state.pid):
        logger.warning(f"âš ï¸ {server_name} process died (PID: {state.pid})")
        state.status = "crashed"
        state.crash_count += 1
        
        if config.auto_restart and state.crash_count < config.max_crashes:
            logger.info(f"ğŸ”„ Auto-restarting {server_name} (crash #{state.crash_count})")
            voice.c3po_announce(f"{server_name} detected offline - Initiating automatic relaunch")
            return launch_server(server_name, force=True)
        else:
            voice.bree_roast(
                f"{server_name} has crashed {state.crash_count} times! "
                f"Disabling auto-restart - manual intervention required!"
            )
            state.status = "disabled"
            return False
    
    # Port-based health check
    if config.server_type == ServerType.PORT and config.port:
        if not check_port(config.port):
            logger.warning(f"âš ï¸ {server_name} port {config.port} not responding")
            state.status = "crashed"
            state.crash_count += 1
            
            if config.auto_restart and state.crash_count < config.max_crashes:
                logger.info(f"ğŸ”„ Auto-restarting {server_name}")
                return launch_server(server_name, force=True)
            else:
                state.status = "disabled"
                return False
    
    # Update health check time
    state.last_health_check = datetime.now()
    return True

def watchdog_thread():
    """Continuous health monitoring thread"""
    logger.info("ğŸ‘ï¸ Watchdog thread started")
    
    while True:
        try:
            for server_name, state in server_states.items():
                if state.status == "running":
                    # Check if health check is due
                    if (not state.last_health_check or 
                        (datetime.now() - state.last_health_check).total_seconds() > state.config.health_check_interval):
                        health_check_server(server_name)
            
            time.sleep(30)  # Check every 30 seconds
        except Exception as e:
            logger.error(f"Watchdog error: {e}")
            time.sleep(60)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMMAND INTERFACE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def take_server_offline(server_name: str) -> bool:
    """Gracefully take server offline"""
    state = server_states.get(server_name)
    if not state:
        logger.error(f"Unknown server: {server_name}")
        return False
    
    if state.status != "running":
        logger.info(f"{server_name} is not running")
        return True
    
    logger.info(f"â¸ï¸ Taking {server_name} offline...")
    voice.c3po_announce(f"Taking {server_name} offline by command")
    
    try:
        if state.pid and is_process_alive(state.pid):
            psutil.Process(state.pid).terminate()
            time.sleep(2)
            
            if is_process_alive(state.pid):
                psutil.Process(state.pid).kill()
        
        state.status = "stopped"
        state.pid = None
        logger.info(f"âœ… {server_name} taken offline")
        return True
    except Exception as e:
        logger.error(f"Failed to stop {server_name}: {e}")
        return False

def bring_server_online(server_name: str) -> bool:
    """Bring server online"""
    logger.info(f"â–¶ï¸ Bringing {server_name} online...")
    voice.c3po_announce(f"Bringing {server_name} online by command")
    return launch_server(server_name, force=True)

def get_diagnostics() -> Dict[str, Any]:
    """Get comprehensive diagnostics"""
    diagnostics = {
        "timestamp": datetime.now().isoformat(),
        "total_servers": len(ALL_SERVERS),
        "running": sum(1 for s in server_states.values() if s.status == "running"),
        "crashed": sum(1 for s in server_states.values() if s.status == "crashed"),
        "disabled": sum(1 for s in server_states.values() if s.status == "disabled"),
        "servers": {}
    }
    
    for name, state in server_states.items():
        diagnostics["servers"][name] = {
            "status": state.status,
            "pid": state.pid,
            "crash_count": state.crash_count,
            "uptime": str(datetime.now() - state.start_time) if state.start_time else None,
            "last_health_check": state.last_health_check.isoformat() if state.last_health_check else None,
            "locked": state.locked,
            "errors": len(state.error_log)
        }
    
    return diagnostics

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN LAUNCHER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    """Main launcher entry point"""
    print("=" * 80)
    print("ğŸš€ UNIFIED MEGA LAUNCHER - ULTIMATE EDITION")
    print("   Authority Level 11.0 - Commander Bobby Don McWilliams II")
    print("=" * 80)
    print(f"   GS343 Foundation: {'âœ…' if GS343_AVAILABLE else 'âŒ'}")
    print(f"   Voice System: {'âœ…' if VOICE_AVAILABLE else 'âŒ'}")
    print(f"   Error Database: âœ… {error_db._get_template_count()} templates")
    print("=" * 80)
    print()
    
    voice.gs343_announce(
        "GS343 Unified Mega Launcher initializing - "
        "Dual architecture deployment commencing - "
        "All systems standing by for launch sequence"
    )
    
    # Start watchdog thread
    watchdog = threading.Thread(target=watchdog_thread, daemon=True)
    watchdog.start()
    
    # Launch all servers
    print("ğŸš€ LAUNCHING MCP_CONSTELLATION SERVERS (VS Code)")
    print("-" * 80)
    for server in CONSTELLATION_SERVERS:
        launch_server(server.name)
        time.sleep(1)
    
    print()
    print("ğŸš€ LAUNCHING ACTIVE_SERVERS (Claude Desktop)")
    print("-" * 80)
    for server in ACTIVE_SERVERS:
        launch_server(server.name)
        time.sleep(1)
    
    # Summary
    print()
    print("=" * 80)
    diagnostics = get_diagnostics()
    print(f"ğŸ“Š LAUNCH COMPLETE")
    print(f"   Running: {diagnostics['running']}/{diagnostics['total_servers']}")
    print(f"   Crashed: {diagnostics['crashed']}")
    print(f"   Disabled: {diagnostics['disabled']}")
    print("=" * 80)
    
    voice.echo_announce(
        f"Launch sequence complete - {diagnostics['running']} of {diagnostics['total_servers']} servers operational - "
        f"Watchdog monitoring active - All systems nominal"
    )
    
    # Keep main thread alive
    try:
        while True:
            time.sleep(60)
            # Periodic diagnostics
            if datetime.now().minute == 0:  # Every hour
                diag = get_diagnostics()
                logger.info(f"ğŸ“Š Hourly diagnostics: {diag['running']} running, {diag['crashed']} crashed")
    except KeyboardInterrupt:
        print("\nğŸ›‘ Shutdown requested...")
        voice.c3po_announce("Shutdown sequence initiated - Terminating all servers")
        
        # Shutdown all servers
        for server_name in server_states.keys():
            take_server_offline(server_name)
        
        # Shutdown voice system
        voice.shutdown()
        
        print("âœ… Shutdown complete")

if __name__ == "__main__":
    main()